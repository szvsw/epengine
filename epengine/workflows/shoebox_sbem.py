"""Simulate an EnergyPlus ubem shoebox model with associated artifacts."""

import asyncio
import hashlib
import logging

import numpy as np
import pandas as pd
from hatchet_sdk import Context

from epengine.hatchet import hatchet
from epengine.models.mixins import WithHContext
from epengine.models.shoebox_sbem import SBEMSimulationSpec
from epengine.utils.results import serialize_df_dict

logger = logging.getLogger(__name__)


class SBEMSimulationSpecWithContext(WithHContext, SBEMSimulationSpec):
    """A simulation specification with a Hatchet Context."""

    pass


# TODO: This could be generated by a class method in the SimulationSpec class
# but should it?
@hatchet.workflow(
    name="simulate_sbem_shoebox",
    timeout="10m",
    version="0.3",
    schedule_timeout="1000m",
)
class SimulateSBEMShoebox:
    """A workflow to simulate an EnergyPlus model."""

    @hatchet.step(name="simulate", timeout="10m", retries=2)
    async def simulate(self, context: Context):
        """Simulate an EnergyPlus Shoebox UBEM model.

        Args:
            context (Context): The context of the workflow

        Returns:
            dict: A dictionary of dataframes with results.
        """

        def run():
            data = context.workflow_input()
            spec = SBEMSimulationSpecWithContext(**data, hcontext=context)
            # _idf, results, err_text = spec.run(log_fn=context.log)
            # context.log(err_text)

            features = spec.feature_dict
            features["experiment_id"] = spec.experiment_id
            features["sort_index"] = spec.sort_index
            results = toy_results(features)

            results = {"results": results}
            return serialize_df_dict(results)

        return await asyncio.to_thread(run)


def toy_results(feature_dict: dict[str, float | int | str]):
    """Toy results for testing."""
    features_as_multiindex = pd.MultiIndex.from_frame(
        pd.DataFrame(feature_dict, index=pd.Index([0]))
    )
    results = pd.DataFrame(
        {"output_1": [0.0], "output_2": [0.0], "output_3": [0.0]},
        index=features_as_multiindex,
    )
    index = results.index.to_frame(index=False)
    index = index[[col for col in index.columns if col.startswith("feature")]]
    numericals = index.select_dtypes(include=[float, int]).values.flatten()
    numericals_squared = (numericals * numericals.reshape(-1, 1)).flatten()
    categoricals = index.select_dtypes(include="object").values.flatten()

    categoricals_hashed = np.array([
        int(hashlib.sha256(cat.encode()).hexdigest()[-2:], 16) for cat in categoricals
    ])

    indicators = np.concatenate([numericals, numericals_squared, categoricals_hashed])
    seed = 42
    gen = np.random.RandomState(seed)
    results_cols = results.columns.to_list()
    coeff_mat = gen.uniform(size=(len(results_cols), len(indicators)))
    linear_terms = coeff_mat @ indicators
    for i, col in enumerate(results_cols):
        results.loc[:, col] = linear_terms[i]
    return results
